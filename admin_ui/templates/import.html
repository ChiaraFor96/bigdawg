{% extends "layout.html" %}

{% set active_page = "import" %}

{% block head_extra %}
    <style type="text/css">
        #desired-format-wrap {
            display: none;
        }
    </style>
    <script src="static/js/util.js"></script>
    <script>
        const datatypes = [
        {% for datatype in datatypes %}
            {
                table_schema: '{{ datatype[0] }}',
                table_name: '{{ datatype[1] }}',
                column_name: '{{ datatype[2] }}',
                data_type: '{{ datatype[3] }}'
            },
        {% endfor %}
        ];

        const databases = [
        {% for database in databases %}
            {
                dbid: {{ database[0] }},
                engine_id: {{ database[1] }},
                name: '{{ database[2] }}',
            },
        {% endfor %}
        ];

        const objects = [
            {% for object in objects %}
                {
                    oid: {{ object[0] }},
                    name: '{{ object[1] }}',
                    fields: '{{ object[2] }}',
                    logical_db: {{ object[3] }},
                    physical_db: {{ object[4] }}
                },
            {% endfor %}
        ];

        const objectsById = [];
        objects.forEach((item) => {
            objectsById[item.oid] = item;
        });

        const datatypesByTable = {};
        datatypes.forEach((item) => {
            const name = item.table_schema + '.' + item.table_name;
            if (!datatypesByTable[name]) {
                datatypesByTable[name] = {};
            }
            datatypesByTable[name][item.column_name] = item.data_type;
        });
    </script>
{% endblock %}

{% block content %}
<div class="row col-xs-10 col-xs-offset-1">
    <div class="selector">
        <label for="database">Database:</label>
        <select name="database" id="database">
            <option value="">Select:</option>
            {% for database in databases %}
                {% if not database[2].startswith("bigdawg") %}
                <option value="{{ database[0] }}">{{ database[0] }}: {{ database[2] }}</option>
                {% endif %}
            {% endfor %}
        </select>
        <label for="object">Object:</label>
        <select name="object" id="object">
            <option>Select Database First</option>
        </select>
    </div>
    <blockquote id="desired-format-wrap">
        <pre id="desired-format">
        </pre>
    </blockquote>
    <div class="loading"></div>
    <div class="upload">
        <input type="file" name="csv" accept=".csv,text/csv"/>
        <input type="checkbox" name="header" /> Contains Header
        <button class="btn btn-primary">Upload CSV</button>
    </div>
</div>
<script>
    const databaseEle = document.getElementById('database');
    const objectEle = document.getElementById('object');
    const desiredFormatEle = document.getElementById('desired-format');
    const desiredFormatWrapEle = document.getElementById('desired-format-wrap');
    const fileEle = document.querySelector('input[type=file]');
    const headerEle = document.querySelector('input[type=checkbox]');

    databaseEle.addEventListener('change', populateObjects);
    objectEle.addEventListener('change', setDesiredFormat);
    fileEle.addEventListener('change', checkFile);

    function checkFile() {
        if (!fileEle.files || !fileEle.files[0]) {
            return;
        }

        const file = fileEle.files[0];
        readFile(file);
    }

    function readFile(file) {
        const reader = new FileReader();
        reader.addEventListener('load', processCsv);
        reader.readAsText(file);
    }

    function processCsv(e) {
        const data = this.result;
        const objectSelected = getSelected(objectEle);
        if (null === objectSelected) {
            alert("Error: no selected object");
            return;
        }
        const object = objectsById[objectSelected];
        if (!object) {
            alert("No object found for oid: " + objectSelected);
            return;
        }
        const fields = object.fields;
        const fieldsSplit = fields.split(',');
        const fieldsCount = fieldsSplit.length;

        const csvLines = data.split(/\r?\n/);
        const csvLinesLen = csvLines.length;
        const csvFinal = [];
        const errors = [];
        csvLines.forEach((line, idx) => {
            if (!line && idx === (csvLinesLen - 1)) {
                // File is ending on a new line, so skip.
                return;
            }
            const parsedLine = parseCsvLine(line);
            if (parsedLine.length !== fieldsCount) {
                errors.push("Line " + (idx + 1) + " has wrong # of fields: " + parsedLine.length + " while expecting " + fieldsCount);
                return;
            }
            if (idx === 0) {
                // Check if header line
                if (headerEle.checked) {
                    // Assume header
                    return;
                }
                let header = true;
                parsedLine.forEach((member, idx) => {
                    if (fieldsSplit[idx] !== member) {
                        header = false;
                    }
                });
                if (header) {
                    headerEle.checked = true;
                    return;
                }
            }

            // convert types
            fieldsSplit.forEach((item, idx) => {
                if (datatypesByTable[object.name] &&
                        datatypesByTable[object.name][fieldsSplit[idx]]) {
                    const dataType = datatypesByTable[object.name][fieldsSplit[idx]];
                    if (dataType === 'integer') {
                        parsedLine[idx] = parseInt(parsedLine[idx]);
                    }
                    if (dataType === 'double precision') {
                        parsedLine[idx] = parseFloat(parsedLine[idx]);
                    }
                }
            });

            csvFinal.push(parsedLine);
        });
        if (errors.length) {
            alert(errors.join("\n"));
        }
        console.log(csvFinal);
    }

    function parseCsvLine(line) {
        let state = 'start';
        const len = line.length;

        const parsed = [];
        let currentPart = "";

        for (let i = 0; i < len; i++) {
            switch (line[i])
            {
                case ',':
                    if (state !== 'quote') {
                        parsed.push(currentPart);
                        currentPart = "";
                    }
                    break;
                case '"':
                    if (state === 'quote') {
                        if (i >= 0 && line[i - 1] === '"') {
                            currentPart += '"';
                        }
                        break;
                    }
                    state = 'quote';
                    break;
                default:
                    currentPart += line[i];
            }

        }
        parsed.push(currentPart);
        return parsed;
    }

    function resetDesiredFormat() {
        desiredFormatEle.innerHTML = '';
        desiredFormatWrapEle.style.display = 'none';
    }

    function setDesiredFormat() {
        const selectedObject = getSelected(objectEle);
        if (null === selectedObject) {
            resetDesiredFormat();
            return;
        }

        const oid = parseInt(selectedObject);
        if (objectsById[oid]) {
            desiredFormatEle.innerHTML = escapeSpecial(objectsById[oid].fields);
            desiredFormatWrapEle.style.display = 'block';
            return;
        }

        resetDesiredFormat();
    }

    function getSelected(ele) {
        if (ele.selectedIndex >= 0) {
            const options = ele.getElementsByTagName('option');
            if (options[ele.selectedIndex]) {
                return options[ele.selectedIndex].value || null;
            }
        }
        return null;
    }

    function populateObjects() {
        const defaultHtml = '<option>Select Database First</option>';
        const selectedDatabase = getSelected(databaseEle);
        if (null === selectedDatabase) {
            objectEle.innerHTML = defaultHtml;
            resetDesiredFormat();
            return;
        }

        let optionHtml = "";
        const selectedDatabaseNum = parseInt(selectedDatabase);
        objects.forEach((item) => {
            if (item.physical_db === selectedDatabaseNum) {
                optionHtml += '<option value="' + item.oid + '">' + escapeSpecial(item.name) + '</option>\n';
            }
        });
        objectEle.innerHTML = optionHtml || defaultHtml;
        setDesiredFormat();
    }
    populateObjects();
</script>

{% endblock %}